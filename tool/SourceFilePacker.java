import java.io.*;
import java.util.*;
import java.util.regex.*;

class SourceFilePacker implements Comparator<File>
{
    public static void main( String[] args )
    {
        File directory = new File( "../" );
        BufferedWriter writer = null;
        try{
            writer = new BufferedWriter( new OutputStreamWriter( new FileOutputStream( "luavsq.lua" ), "UTF-8" ) );
            writeHeader( writer );
            File[] files = sortSourceFiles( directory.listFiles() );
            for( File file : files ){
                concatFile( file.getAbsolutePath(), writer );
            }
        }catch( Exception e ){
            e.printStackTrace();
        }finally{
            if( writer != null ){
                try{
                    writer.close();
                }catch( Exception e ){}
            }
        }
    }

    private static File[] sortSourceFiles( File[] files )
    {
        Vector<File> paths = new Vector<File>();
        for( File file : files ){
            if( false == file.getAbsolutePath().endsWith( ".lua" ) ){
                continue;
            }
            paths.add( file );
        }

        Collections.sort( paths, new SourceFilePacker() );

        return paths.toArray( new File[0] );
    }

    private static void writeHeader( BufferedWriter writer )
        throws IOException
    {
        int startYear = 2011;
        int currentYear = Calendar.getInstance().get( Calendar.YEAR );
        String year = "" + startYear;
        if( startYear != currentYear ){
            year = Math.min( startYear, currentYear ) + "-" + Math.max( startYear, currentYear );
        }
        String[] license = new String[]{
            "--[[",
            "  luavsq.lua",
            "  Copyright © " + year + " kbinani, All Rights Reserved.",
            "",
            "  luavsq is free software; you can redistribute it and/or",
            "  modify it under the terms of the GPL version 3 License.",
            "",
            "  luavsq is distributed in the hope that it will be useful,",
            "  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.",
            "]]",
            "",
            "-- This file is automatically generated by SourceFilePacker.",
            "-- To generate this file, just execute the command below:",
            "--     $cd tool && make",
            "-- See tool/makefile and tool/SourceFilePacker.java.",
            "",
            "if( nil == luavsq )then",
            "\tluavsq = {};",
            "end"
        };
        for( String line : license ){
            writer.write( line );
            writer.newLine();
        }
    }

    private static void concatFile( String path, BufferedWriter writer )
    {
        BufferedReader reader = null;
        StringBuilder builder = new StringBuilder();
        try{
            reader = new BufferedReader( new InputStreamReader( new FileInputStream( path ), "UTF-8" ) );
            boolean first = true;
            while( reader.ready() ){
                if( !first ){
                    builder.append( "\n" );
                }else{
                    first = false;
                }
                builder.append( reader.readLine() );
            }
            String source = builder.toString();
            source = extract( source, new File( path ).getName().replace( ".lua", "" ) );
            source = packAll( source );
            writer.write( source );
        }catch( Exception e ){
            e.printStackTrace();
        }finally{
            if( reader != null ){
                try{
                    reader.close();
                }catch( Exception e ){}
            }
        }
    }

    private static String packAll( String source )
    {
        Pattern pattern = null;
        Matcher matcher = null;

        // 長いコメントを削除
        pattern = Pattern.compile( "--\\[\\[.*?\\]\\]", Pattern.DOTALL );
        matcher = pattern.matcher( source );
        if( matcher.find() ){
            source = matcher.replaceAll( "" );
        }

        // 行コメントを削除
        pattern = Pattern.compile( "--.*?\n" );
        matcher = pattern.matcher( source );
        if( matcher.find() ){
            source = matcher.replaceAll( "\n" );
        }

        // 空白のみの行を削除
        pattern = Pattern.compile( "^[ ]*$", Pattern.MULTILINE );
        matcher = pattern.matcher( source );
        if( matcher.find() ){
            source = matcher.replaceAll( "" );
        }

        // 連続した改行を削除
        pattern = Pattern.compile( "\n\n", Pattern.MULTILINE );
        while( true ){
            matcher = pattern.matcher( source );
            if( false == matcher.find() ){
                break;
            }
            source = matcher.replaceAll( "\n" );
        }

        // インデントをタブでやるようにする
        int tabCount = 0;
        while( true ){
            String patternString = "^";
            for( int i = 0; i < tabCount; i++ ){
                patternString += "\\t";
            }
            tabCount++;
            patternString += "[ ]{4}";
            pattern = Pattern.compile( patternString, Pattern.MULTILINE );
            matcher = pattern.matcher( source );
            if( matcher.find() ){
                String replace = "";
                for( int i = 0; i < tabCount; i++ ){
                    replace += "\t";
                }
                source = matcher.replaceAll( replace );
            }else{
                break;
            }
        }

        return source;
    }

    private static String extract( String source, String className )
    {
        String patternString = "if\\( nil == luavsq\\." + className + " \\)then\n(.*)end";
        Pattern pattern = Pattern.compile( patternString, Pattern.DOTALL );
        Matcher matcher = pattern.matcher( source );
        if( matcher.find() ){
            source = matcher.group( 1 );

            // インデントを1つ解除
            pattern = Pattern.compile( "^[ ]{4}", Pattern.MULTILINE );
            matcher = pattern.matcher( source );
            source = matcher.replaceAll( "" );
        }
        return source;
    }

    public int compare( File a, File b )
    {
        if( a != null && b != null && a instanceof File && b instanceof File ){
            String pathA = ((File)a).getName();
            String pathB = ((File)b).getName();
            if( pathA.endsWith( ".lua" ) ){
                pathA = pathA.substring( 0, pathA.length() - 4 );
            }
            if( pathB.endsWith( ".lua" ) ){
                pathB = pathB.substring( 0, pathB.length() - 4 );
            }
            return pathA.compareTo( pathB );
        }else{
            return 0;
        }
    }
}
